<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Markup App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    #toolbar {
      display: flex;
      align-items: center;
      padding: 10px;
      background: #f5f5f5;
      flex-wrap: wrap;
    }
    .color-dot-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 5px;
      font-size: 12px;
    }
    .color-dot {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .selected {
      border-color: black;
    }
    #canvas-container {
      position: relative;
      overflow: auto;
      width: 100%;
      height: 80vh;
      border: 1px solid #ccc;
    }
    canvas {
      display: block;
    }
    .mark {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      pointer-events: none;
    }
    .reset-button {
      font-size: 10px;
      margin-top: 2px;
      cursor: pointer;
      color: blue;
      text-decoration: underline;
      border: none;
      background: none;
    }
    #zoom-level {
      margin-left: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="toolbar"></div>
  <input type="file" id="upload" accept="application/pdf">
  <button onclick="savePDF()">Save Marked PDF</button>
  <button onclick="resetMarks()">Reset</button>
  <button onclick="zoomIn()">Zoom In</button>
  <button onclick="zoomOut()">Zoom Out</button>
  <button onclick="fitToScreen()">Fit to Screen</button>
  <button onclick="toggleFullscreen()">Fullscreen</button>
  <span id="zoom-level">Zoom: 100%</span>
  <div id="canvas-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script>
    const colors = ['red', 'green', 'blue', 'orange', 'purple', 'cyan', 'magenta', 'yellow', 'black', 'gray'];
    const counts = {};
    const marks = [];
    let selectedColor = colors[0];
    let pdf = null, currentPage = null, viewport = null, scale = 1;

    const toolbar = document.getElementById('toolbar');
    const container = document.getElementById('canvas-container');
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const zoomDisplay = document.getElementById('zoom-level');

    function updateZoomLevel() {
      zoomDisplay.textContent = `Zoom: ${Math.round(scale * 100)}%`;
    }

    colors.forEach(color => {
      const wrapper = document.createElement('div');
      wrapper.className = 'color-dot-wrapper';

      const dot = document.createElement('div');
      dot.className = 'color-dot';
      dot.style.backgroundColor = color;
      dot.dataset.color = color;
      if (color === selectedColor) dot.classList.add('selected');
      dot.onclick = () => {
        document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('selected'));
        dot.classList.add('selected');
        selectedColor = color;
      };

      const countText = document.createElement('div');
      countText.id = `count-${color}`;
      countText.textContent = '0';

      const resetBtn = document.createElement('button');
      resetBtn.textContent = 'Reset';
      resetBtn.className = 'reset-button';
      resetBtn.onclick = () => {
        for (let i = marks.length - 1; i >= 0; i--) {
          if (marks[i].color === color) marks.splice(i, 1);
        }
        counts[color] = 0;
        updateCounts();
        document.querySelectorAll(`.mark`).forEach(mark => {
          if (mark.style.backgroundColor === color) mark.remove();
        });
      };

      wrapper.appendChild(dot);
      wrapper.appendChild(countText);
      wrapper.appendChild(resetBtn);
      toolbar.appendChild(wrapper);

      counts[color] = 0;
    });

    function updateCounts() {
      colors.forEach(color => {
        document.getElementById(`count-${color}`).textContent = counts[color];
      });
    }

    document.getElementById('upload').addEventListener('change', e => {
      const file = e.target.files[0];
      if (file.type !== 'application/pdf') return;
      const reader = new FileReader();
      reader.onload = function () {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(doc => {
          pdf = doc;
          renderPage(1);
        });
      };
      reader.readAsArrayBuffer(file);
    });

    function renderPage(pageNum) {
      pdf.getPage(pageNum).then(page => {
        currentPage = page;
        viewport = page.getViewport({ scale: scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        container.style.width = viewport.width + 'px';
        container.style.height = viewport.height + 'px';
        const renderContext = { canvasContext: ctx, viewport: viewport };
        page.render(renderContext);
        redrawMarks();
        updateZoomLevel();
      });
    }

    function zoomIn() {
      scale += 0.1;
      renderPage(1);
    }

    function zoomOut() {
      if (scale > 0.2) {
        scale -= 0.1;
        renderPage(1);
      }
    }

    function fitToScreen() {
      if (!viewport) return;
      const containerWidth = window.innerWidth - 40;
      scale = containerWidth / viewport.width;
      renderPage(1);
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    function redrawMarks() {
      document.querySelectorAll('.mark').forEach(mark => mark.remove());
      marks.forEach(({ x, y, color }) => {
        const scaledX = x * scale;
        const scaledY = y * scale;
        const dot = document.createElement('div');
        dot.className = 'mark';
        dot.style.left = `${scaledX - 5}px`;
        dot.style.top = `${scaledY - 5}px`;
        dot.style.backgroundColor = color;
        container.appendChild(dot);
      });
    }

    container.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / scale;
      const y = (e.clientY - rect.top) / scale;

      const dot = document.createElement('div');
      dot.className = 'mark';
      dot.style.left = `${x * scale - 5}px`;
      dot.style.top = `${y * scale - 5}px`;
      dot.style.backgroundColor = selectedColor;
      container.appendChild(dot);

      marks.push({ x, y, color: selectedColor });
      counts[selectedColor]++;
      updateCounts();
    });

    function resetMarks() {
      marks.length = 0;
      colors.forEach(color => counts[color] = 0);
      updateCounts();
      document.querySelectorAll('.mark').forEach(mark => mark.remove());
    }

    async function savePDF() {
      const { jsPDF } = window.jspdf;
      const pdfDoc = new jsPDF({ unit: 'px', format: [canvas.width, canvas.height] });
      const imgData = canvas.toDataURL('image/jpeg');
      pdfDoc.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);

      marks.forEach(mark => {
        pdfDoc.setFillColor(mark.color);
        pdfDoc.circle(mark.x, mark.y, 5, 'F');
      });

      pdfDoc.setFontSize(12);
      let textY = 20;
      pdfDoc.setTextColor(0, 0, 0);
      pdfDoc.text('Color Counts:', 10, textY);
      textY += 15;
      colors.forEach(color => {
        if (counts[color] > 0) {
          pdfDoc.setTextColor(color);
          pdfDoc.text(`${color}: ${counts[color]}`, 10, textY);
          textY += 15;
        }
      });

      pdfDoc.save('marked.pdf');
    }

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === '+') {
        e.preventDefault();
        zoomIn();
      } else if (e.ctrlKey && e.key === '-') {
        e.preventDefault();
        zoomOut();
      }
    });
  </script>
</body>
</html>
